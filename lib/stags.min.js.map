{"version":3,"file":"stags.min.js","sources":["../lib/core.js","../lib/bifunctor.js","../lib/decorate.js","../lib/index.js","../lib/functor.js","../lib/monad.js"],"sourcesContent":["/* globals Symbol */\n\nexport const run = (initial, ...fns) => {\n    if( fns.length == 0){\n        throw new Error(\n            'You must provide an initial value and a non-empty spread of functions.'\n        )\n    }\n    return fns.reduce( (p, f) => f(p), initial )\n}\n\nexport const otherwise = tagNames => f => \n    tagNames.reduce(\n        (p,k) => Object.assign(p, { [k]: f }), {}\n    )\n\nexport const _fold = () => \n    fns => M => fns[tagName(M)](M.value)\n\nexport const pipe = (...fns) => {\n    if( fns.length == 0){\n        throw new Error(\n            'You must provide a non-empty spread of functions.'\n        )\n    }\n    return initial => run(initial, ...fns)\n}\n\nexport const repeat = (n,x) => Array(n).fill(x)\nexport const repeatStr = (n,x) => n > 0 ? repeat(n,x).join('') : ''\n\nexport function annotate(visitor, value){\n  const notPrimative = Object(value) === value\n  const isNil = value == null\n  const isArray = notPrimative && Array.isArray(value)\n  const isObject = notPrimative && !isArray\n  const isFunction = notPrimative && typeof value === 'function'\n  const isPrimative = !notPrimative\n  const isStag = isObject && value.type && tagName(value)\n  const valueStag = isStag && 'value' in value\n  const emptyStag = isStag && !valueStag\n  const isPojo = isObject && value.constructor.name == 'Object'\n  const isDate = isObject && value instanceof Date\n  const isError = isObject && value instanceof Error\n  const isString = typeof value === 'string'\n  \n  return visitor({ \n    notPrimative, \n    isPrimative, \n    isString,\n    isNil,\n    isArray, \n    isObject, \n    isPojo,\n    isDate,\n    isError,\n    value,\n    isFunction,\n    isStag, \n    valueStag,\n    emptyStag\n  })\n}\n\n\nexport const toString = x => \n  annotate((function visitor(indentation){\n    return (annotation) => {\n    \n      const { \n        value\n        , isPojo\n        , isObject\n        , isArray\n        , isDate\n        , isError\n        , valueStag\n        , emptyStag\n        , isString \n        , isFunction\n      } = annotation\n\n      const indentChar = ''\n      const tab = repeatStr(indentation, indentChar)\n      const tabLess = repeatStr(indentation-1, indentChar)\n      const tab2 = repeatStr(indentation+1, indentChar)\n      const newLine = ''\n\n      return (\n        valueStag\n          ? value.type+'.'+tagName(value)+'('\n              + (typeof value.value === 'undefined'\n                ? ''\n                : annotate( visitor(indentation+1),  value.value ))\n            + ( indentation > 0 ? newLine + tabLess : '' ) + newLine + tab + ')'\n        : emptyStag\n          ? value.type+'.'+tagName(value)+'()'\n        : isPojo \n          ? Object.keys(value).length == 0\n            ? '{}'\n            : run(\n                value\n                , Object.entries\n                , xs => xs.map(\n                    ([key, value]) => \n                        newLine + tab2 + '\"' + key +'\":'\n                            + annotate(visitor(indentation+1), value)\n                              .replace(newLine+tab2, '')\n                )\n                , strings => newLine+tab+'{' + strings + newLine + tab + '}'\n            )\n      : isArray\n        ? value.length == '0' \n          ? '[]'\n          : newLine + tab + '['\n              + newLine + tab + tab + value.map( \n                x => annotate(visitor(indentation+1), x) \n              )\n              .join(', ') \n          + newLine + tab + ']'\n      : isDate\n        ? 'new ' + value.constructor.name + '(\"' \n          + value.toISOString() \n        + '\")'\n      : isError\n        ? 'new ' + value.constructor.name + '(\"' \n          + value.message \n        + '\")'\n      : isFunction\n        ? value + ''\n      : isObject\n        ? 'new ' + value.constructor.name + '()'\n      : isString\n        ? JSON.stringify(value)\n      : '' + value\n    )\n  }\n})(0), x)\n\nexport const toJSON = x => \n  annotate(function visitor({\n    value, isPojo, isArray, valueStag, emptyStag\n  }){\n    const out = (\n      valueStag\n        ? annotate(visitor, value.value)  \n      : emptyStag\n        ? null\n      : isPojo \n        ? fromEntries(\n          Object.entries(value).map( value => annotate(visitor, value) )\n        )\n      : isArray\n        ? value.map( value => annotate(visitor, value) )\n      : value\n    )\n\n    return out\n  }, x)\n\nexport function boundToString(){\n    return toString(this)\n}\n\nexport function typeName(instance){\n    return instance.type\n}\n\nexport function tagName(instance){\n    if( 'tag' in instance ) {\n        return instance.tag\n    } else {\n        // temporary migration\n        return instance.case\n    }\n}\n\nexport const proto = \n    { toString: boundToString\n    , inspect: boundToString\n    , [Symbol.for('nodejs.util.inspect.custom')]: boundToString\n    }\n\nexport function valueInstance(type, tag, value){\n    return Object.assign( Object.create(proto), {\n        type, \n        tag,\n        value\n    })\n}\n\nexport function emptyInstance(type, tag){\n    return Object.assign( Object.create(proto), { \n        type, tag\n    })\n}\n\nexport const fromEntries = pairs =>\n  pairs.reduce(\n    (p, [k,v]) => ({ ...p, [k]: v }), {}\n  )\n\n\nexport const StaticSumTypeError =\n  [ 'ExtraTags'\n  , 'MissingTags'\n  , 'InstanceNull'\n  , 'InstanceWrongType'\n  , 'InstanceShapeInvalid'\n  , 'VisitorNotAFunction'\n  , 'NotAType'\n  , 'TagsShapeInvalid'\n  ]\n  .reduce(\n      (p,n) => {\n          p[n] = value => valueInstance(p.type, n, value)\n          p.tags.push(n)\n          return p\n      }\n      ,{\n          type: 'StaticSumTypeError',\n          tags: [],\n          specs: {}\n      }\n  )\n\nexport function getTags(T) {\n  return T.tags\n}\n\nexport const ErrMessageTags =\n  { ExtraTags: function ExtraTags(o) {\n      return (\n          ['Your tag function must have exactly the same'\n              , ' keys as the type: ' + o.T.type + '. '\n              , 'The following tags should not have been present:'\n              , o.extraKeys.join(', ')\n          ].join(' ')\n      )\n  }\n  , MissingTags: function MissingTags(o) {\n      return (\n          [\n              'Your tag function must have exactly the same'\n              , 'keys as the type: ' + o.T.type + '. The following keys were'\n              , 'missing:'\n              , o.missingKeys.join(', ')\n          ]\n      )\n          .join(' ')\n  }\n\n  , InstanceNull: function InstanceNull(o) {\n      return (\n          'Null is not a valid member of the type ' + o.T.type\n      )\n  }\n\n  , InstanceWrongType: function InstanceWrongType(o) {\n      return (\n          [toString(o.x) + ' is not a valid member of the type'\n              , o.T.type\n              , 'which expects the following tags'\n              , getTags(o.T).join(' | ')\n          ]\n      )\n          .join(' ')\n  }\n\n  , InstanceShapeInvalid: function InstanceShapeInvalid(o) {\n      return [\n          toString(o.x)\n          , 'is not a valid Member of the type:'\n          , o.T.type + '. '\n          , 'Please review the definition of ' + o.T.type\n      ]\n          .join(' ')\n  }\n  , VisitorNotAFunction: function (o) {\n      return o.context + ' expected a visitor function '\n          + ' but instead received ' + toString(o.visitor)\n  }\n  , NotAType: function (o) {\n      return o.context + ' expected a Type ({ type: string, tags: string[] })'\n          + ' but received ' + toString(o.T)\n  }\n  , TagsShapeInvalid(T, tags){\n      return 'fold('+typeName(T)+') tags provided were not the right shape.  '\n          + 'Expected { [tag]: f } but received ' + toString(tags)\n  }\n}\n\nexport function foldT( getT ) {\n  const T = getT()\n  assertValidType('fold', T)\n  return function devCata$T(tags) {\n      assertValidCata(T, tags)\n\n      const tagNames =\n          Object.keys(tags)\n\n      const tKeys =\n          getTags(T)\n\n      const xKeys = [\n          [tagNames, T]\n          , [tKeys, tags]\n      ]\n          .map(\n              function (t) {\n                  const xs = t[0]\n                  const index = t[1]\n                  return xs.filter(function (x) {\n                      return !(x in index)\n                  })\n              }\n          )\n\n      const extraKeys = xKeys[0]\n      const missingKeys = xKeys[1]\n\n      if (missingKeys.length > 0) {\n          return handleError(\n              Err.MissingTags({ T: T, tags, missingKeys: missingKeys })\n          )\n      } else if (extraKeys.length > 0) {\n          return handleError(\n              Err.ExtraTags({ T: T, tags, extraKeys: extraKeys })\n          )\n      } else {\n          return function (x) {\n\n              return beforeFoldEval(T, tags, x) \n                  && tags[tagName(x)](x.value)\n          }\n      }\n\n  }\n}\n\n\nexport const errMessage = err => \n  _fold(StaticSumTypeError)(ErrMessageTags)(err)\n\nexport function handleError(err) {\n  const e = new Error(tagName(err) + ': ' + errMessage(err))\n  throw e\n}\n\nexport const Err = StaticSumTypeError\n\nexport function assertValidType(context, T) {\n  if (\n      T == null\n      || \n      !(\n          T != null \n          && typeof T.type == 'string' \n          && Array.isArray(T.tags)\n          && 'specs' in T\n      ) \n  ) {\n      return handleError(\n          Err.NotAType({ context, T })\n      )\n  }\n}\n\nexport function assertValidVisitor(o) {\n    if (typeof o.visitor != 'function') {\n        return handleError(\n            Err.VisitorNotAFunction({ context: o.context, visitor: o.visitor })\n        )\n    }\n}\n\nexport function assertValidTag(T, instance) {\n    if (!(\n        instance != null\n        && typeName(instance) == T.type\n        && getTags(T).includes(tagName(instance))\n    )) {\n        return handleError(\n            Err.InstanceShapeInvalid({\n                x: instance\n                , T: T\n            })\n        )\n    }\n}\n\nexport function assertValidCata(T, tags){\n  if( \n      tags != null\n      && !Array.isArray(tags) \n      && typeof tags === 'object'\n  ) {\n      return true\n  } else {\n      const err = Err.TagsShapeInvalid(T, tags)\n      return handleError(\n          err\n      )\n  }\n}\n\nexport function beforeFoldEval(T, tags, x){\n  return x == null\n      ? handleError(\n          Err.InstanceNull({\n              T: T, tags, x: x\n          })\n      )\n  : typeName(x) !== T.type\n      ? handleError(\n          Err.InstanceWrongType({\n              T: T, tags, x: x\n          })\n      )\n  : !(getTags(T).includes(tagName(x)))\n      ? handleError(\n          Err.InstanceShapeInvalid({\n              T: T, tags, x: x\n          })\n      )\n      : true\n}\n\nexport function fold(T) {\n  return foldT( () => T )\n}\n\n\nexport const mapAll = T => {\n    const foldT = fold(T)\n\n    return tags => {\n        const foldTags = foldT(tags)\n        return Ma => {\n            assertValidTag(T, Ma)\n            const value = foldTags(Ma)\n            return T[tagName(Ma)](value)\n        }\n    }\n}\n\nexport const chainAll = T => {\n    const foldT = fold(T)\n\n    return tags => {\n        const foldTags = foldT(tags)\n\n        return Ma => {\n            beforeFoldEval(\n                T, tags, Ma\n            )\n            if( 'value' in Ma ){\n\n                const nestedValue = foldTags(Ma)\n\n                return beforeFoldEval(\n                    T, tags, nestedValue\n                )\n                && nestedValue\n            } else {\n                return Ma\n            }\n        }\n    }\n}\n\nexport const tags = (type, tagNames) => {\n    return {\n        type,\n        specs: {},\n        tags: tagNames,\n        ...fromEntries(\n            tagNames.map(\n                tagName => [ tagName, (...args) => \n                    args.length \n                        ? valueInstance(type, tagName, args[0]) \n                        : emptyInstance(type, tagName)\n                ]\n            )\n        )\n    }\n}\n\nexport function either(type){\n    return tags(type, ['Y', 'N'])\n}\n\nexport const Either = either('stags.Either')\n","import \n    { assertValidVisitor\n    , assertValidType\n    , assertValidTag\n    , fold\n    , mapAll\n    , tagName \n    } \nfrom './core'\n\nexport const all = T => Ms => {\n    const bad = Ms.filter( M => !T.toBoolean (M) )\n\n    if( bad.length > 0 ) {\n        return T.left( bad.map( x => x.value ) )\n    } else {\n        return T.right( Ms.map( T.getOr( null) ) )\n    }\n}\n\nexport const any = T => Ms =>\n    Ms.some( T.toBoolean )\n        ? T.right( Ms.filter( T.toBoolean ).map( T.getOr(null) ) )\n        : Ms.find( M => !T.toBoolean(M) )\n\nexport const _bifold = T => {\n    const $fold = fold(T)\n    const { left, right } = T.specs['stags/bifunctor']\n\n    return (leftF, rightF) => \n        $fold({ [left]: leftF, [right]: rightF })\n}\n\nexport const bifold = T => {\n    assertValidType('bifold', T)\n\n    return _bifold(T)\n}\n\nexport const _bimap = T => {\n    const _mapAll = mapAll(T)\n    const { left, right } = T.specs['stags/bifunctor']\n    \n    return (leftF, rightF) => \n        _mapAll({ \n            [left]: leftF, [right]: rightF\n        })\n}\n\nexport const bimap = T => {\n    assertValidType('bimap', T)\n    \n    return _bimap(T)\n}\n\nexport const _getOr = T => or =>\n    _bifold (T) (\n        () => or, x => x\n    )\n\nexport const getOr = T => {\n    assertValidType('getOr', T)\n\n    return or => {\n        return M => {\n            assertValidTag(T, M)\n    \n            return _getOr (T) (or) (M)\n        }\n    }\n}\n\nexport const getWith = T => (otherwise, f) =>\n    bifold(T) (\n        () => otherwise, x => f(x)\n    )\n\nexport const tagBy = T => {\n    fold(T) // just validates T\n    return (otherwise, visitor) => a => {\n        assertValidVisitor({ context: 'tagBy', visitor })\n        return visitor(a) ? T.right(a) : T.left(otherwise)\n    }\n}\n\nexport const toBoolean = T => T.bifold(\n    () => false,\n    () => true\n)\n\nexport const fromNullable = T => x => \n    x == null ? T.left(x) : T.right(x)\n\nexport const encase = T => f => x => {\n    try {\n        return T.right(f(x))\n    } catch (e) {\n        return T.left(e)\n    }\n}\n\n\nexport const _concatWith = T => f => A => B => {\n    const { left, right } = T.specs['stags/bifunctor']\n\n    return (\n        tagName(A) == left\n            ? A\n        : tagName(B) == left\n            ? B\n        : T[right](\n            f ( A.value ) ( B.value )\n        )\n    )\n}\n\nexport const concatWith = T => {\n    assertValidType('concatWith', T)\n\n    return f => {\n        assertValidVisitor({\n            context: 'concatWith',\n            visitor: f\n        })\n\n        \n        return A => {\n            assertValidTag(T, A)\n\n            return B => {\n                assertValidTag(T, B)\n                return _concatWith (T) (f) (A) (B)\n            }\n        }\n    }\n}\n\nexport const spec = ({ left, right }) => T => {\n    T.specs['stags/bifunctor'] = { left, right }\n\n    T.left = x => T[left](x)\n    T.right = x => T[right](x)\n    T.bifold = bifold(T)\n    T.bimap = bimap(T)\n    T.getOr = getOr(T)\n    T.getWith = getWith(T)\n    T.tagBy = tagBy(T)\n    T.encase = encase(T)\n    T.toBoolean = toBoolean(T)\n    T.fromNullable = fromNullable(T)\n    T.all = all(T)\n    T.any = any(T)\n\n    T.concatWith = concatWith(T)\n\n    return T\n}\n","import \n    { assertValidTag\n    , getTags\n    , tagName\n    , fold\n    , mapAll\n    , chainAll\n    , otherwise\n    , Either\n    }\nfrom './core'\n\n\nexport function spec(T){\n    if( T.specs['stags/decorated'] ){\n        return T\n    } else {\n        // Do not expose this, they need to define their own _\n        const _ = otherwise(getTags(T))\n\n        const mapT = mapAll(T)\n        const chainT = chainAll(T)\n        const foldT = fold(T)\n    \n        getTags(T).forEach(\n            k => {\n                T['is'+k] = T['is'+k] || (M => {\n                    assertValidTag(T, M)\n                    return tagName(M) === k\n                })\n    \n                T['map'+k] = T['map'+k] || (f => mapT({\n                    ..._( x => x )\n                    ,[k]: f\n                }))\n    \n                T['get'+k+'Or'] = T['get'+k+'Or'] || (otherwise => foldT({\n                    ..._( () => otherwise )\n                    ,[k]: x => x\n                }))\n    \n                T['get'+k+'With'] = T['get'+k+'With'] || ((otherwise, f) => foldT({\n                    ..._( () => otherwise )\n                    ,[k]: x => f(x)\n                }))\n    \n                T['chain'+k] = T['chain'+k] || (f => x => \n                    chainT({\n                        ..._( () => x )\n                        ,[k]: f\n                    }) (x))\n\n                T['assert'+k] = T['assert'+k] || (foldT({\n                    ..._( Either.N )\n                    ,[k]: Either.Y\n                }))\n\n                T[k.toLowerCase()+'s'] = T[k+'s'] || (xs => xs.reduce(\n                    (p,n) => p.concat(\n                        T['is'+k](n) ? [n.value] : []\n                    )\n                    , []\n                ))\n            }\n        )\n        T.fold = T.fold || foldT\n        T.mapAll = T.mapAll || mapT\n        T.chainAll = T.chainAll || chainT\n\n        T.specs['stags/decorated'] = true\n        return T\n    }\n}\n","import \n    { valueInstance\n    , emptyInstance\n    , typeName\n    , getTags\n    , tagName\n    , fold\n    , mapAll\n    , chainAll\n    , otherwise\n    , run\n    , pipe\n    , toJSON\n    , toString\n    , errMessage\n    , StaticSumTypeError\n    , boundToString\n    , either\n    , tags\n    }\nfrom './core'\n\nimport { spec as bifunctor } from './bifunctor'\nimport { spec as functor } from './functor'\nimport { spec as monad } from './monad'\nimport { spec as decorate } from './decorate'\n\nconst externalEither = name => \n    run(\n        either(name)\n        ,decorate\n        ,bifunctor({ left: 'N', right: 'Y' })\n        ,functor('Y')\n        ,monad('Y')\n    )\n\nconst externalMaybe = name =>\n    run(\n        name\n        ,externalEither\n        ,x => {\n            const oldN = x.N\n            x.N = () => oldN()\n            x.specs['stags/maybe'] = true\n            return x\n        }\n    )\n\nconst externalTags = (type, tagNames) => \n    decorate(tags(type, tagNames))\n\nconst decoratedEither = externalEither('stags.Either')\n\nconst { \n    Y\n    , N\n    , bifold: Ebifold\n    , getOr: EgetOr\n    , getWith: EgetWith\n    , bimap: Ebimap\n    , map: Emap\n    , mapY: EmapY\n    , mapN: EmapN\n    , assertY: EassertY\n    , assertN: EassertN\n    , chainN: EchainN\n    , chainY: EchainY\n    , tagBy: EtagBy\n    , chain: Echain\n    , toBoolean: EtoBoolean\n    , encase: Eencase\n    , fromNullable: EfromNullable\n    , all: Eall\n    , any: Eany\n    , isY: EisY\n    , isN: EisN\n    , ys: Eys\n    , ns: Ens\n    , concatWith: EconcatWith\n} = decoratedEither\n\nexport {\n    fold\n    , Y\n    , N\n    , Ebifold as bifold\n    , EgetOr as getOr\n    , EgetWith as getWith\n    , Ebimap as bimap\n    , Emap as map\n    , EmapY as mapY\n    , EmapN as mapN\n    , EassertY as assertY\n    , EassertN as assertN\n    , EchainN as chainN\n    , EchainY as chainY\n    , EtagBy as tagBy\n    , Echain as chain\n    , EtoBoolean as toBoolean\n    , Eencase as encase\n    , EfromNullable as fromNullable\n    , Eall as all\n    , Eany as any\n    , EisY as isY\n    , EisN as isN\n    , Eys as ys\n    , Ens as ns\n    , EconcatWith as concatWith\n    , externalEither as either\n    , externalMaybe as maybe\n    , decoratedEither as Either\n    , valueInstance\n    , emptyInstance\n    , toString\n    , toJSON\n    , otherwise\n    , tagName\n    , typeName\n    , getTags\n    , pipe\n    , run\n    , externalTags as tags\n    , decorate\n    , mapAll\n    , chainAll\n    , errMessage\n    , StaticSumTypeError\n    , boundToString\n}\n\n\n// migration\nexport const caseName = tagName\nexport const getCases = getTags\nexport const valueCaseInstance = valueInstance\nexport const emptyCaseInstance = emptyInstance\nexport const sameCase = (a,b) => \n    tagName(a) === tagName(b)\nexport const tagged = typeName => def =>\n    tags(typeName, Object.keys(def))\n\nexport const Maybe = externalMaybe('stags.Maybe')","import \n    { assertValidVisitor\n    , otherwise\n    , mapAll\n    } \nfrom './core'\n\nexport const spec = (tag) => T => {\n    T.specs['stags/functor'] = tag\n\n    T.of = T[tag]\n    T.map = f => {\n        assertValidVisitor({ context: 'map', visitor: f })\n        return mapAll(T) ({\n            ...otherwise(T.tags) ( x => x )\n            ,[tag]: f\n        })\n    }\n\n    return T\n}\n","import \n    { assertValidVisitor\n    , chainAll\n    , otherwise\n    , tagName \n    } \nfrom './core'\n\nexport const spec = (tag) => T => {\n    T.specs['stags/monad'] = tag\n\n    T.of = T[tag]\n    const chainAllT = chainAll(T)\n\n    T.chain = f => {\n        assertValidVisitor({ context: 'chain', visitor: f })\n\n        return M => {\n            return chainAllT({\n                ...otherwise(T.tags) ( x => T[tagName(M)](x) )\n                ,[tag]: x => f(x)\n            }) (M)\n        }\n    }\n    return T\n}\n"],"names":["run","initial","fns","length","Error","reduce","p","f","otherwise","tagNames","k","Object","assign","repeatStr","n","x","Array","fill","repeat","join","annotate","visitor","value","notPrimative","isNil","isArray","isObject","isFunction","isPrimative","isStag","type","tagName","valueStag","emptyStag","isString","isPojo","constructor","name","isDate","Date","isError","toString","indentation","annotation","tab","tabLess","tab2","keys","entries","xs","map","key","replace","strings","toISOString","message","JSON","stringify","boundToString","this","typeName","instance","tag","case","proto","inspect","Symbol","for","valueInstance","create","emptyInstance","fromEntries","pairs","StaticSumTypeError","tags","push","specs","getTags","T","ErrMessageTags","ExtraTags","o","extraKeys","MissingTags","missingKeys","InstanceNull","InstanceWrongType","InstanceShapeInvalid","VisitorNotAFunction","context","NotAType","TagsShapeInvalid","foldT","getT","assertValidType","_typeof","err","Err","handleError","assertValidCata","tKeys","xKeys","t","index","filter","beforeFoldEval","errMessage","M","assertValidVisitor","assertValidTag","includes","fold","mapAll","foldTags","Ma","chainAll","nestedValue","arguments","either","Either","_bifold","$fold","left","right","leftF","rightF","bifold","bimap","_mapAll","_bimap","getOr","or","_getOr","concatWith","A","B","_concatWith","spec","getWith","tagBy","a","encase","e","toBoolean","fromNullable","all","Ms","bad","any","some","find","_","mapT","chainT","forEach","N","Y","toLowerCase","concat","externalEither","decorate","bifunctor","of","chainAllT","chain","monad","externalMaybe","oldN","decoratedEither","Ebifold","EgetOr","EgetWith","Ebimap","Emap","EmapY","mapY","EmapN","mapN","EassertY","assertY","EassertN","assertN","EchainN","chainN","EchainY","chainY","EtagBy","Echain","EtoBoolean","Eencase","EfromNullable","Eall","Eany","EisY","isY","EisN","isN","Eys","ys","Ens","ns","EconcatWith","caseName","getCases","valueCaseInstance","emptyCaseInstance","Maybe","b","def"],"mappings":"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"}