{"version":3,"file":"superouter.min.js","sources":["../lib/index.js"],"sourcesContent":["const Valid = {\n    name: 'Valid'\n    ,Y: value => ({ case: 'Y', type: 'Valid', value})\n    ,N: value => ({ case: 'N', type: 'Valid', value})\n    ,bifold: (N,Y) => o => ({\n        Y\n        ,N\n    })[o.case](o.value)\n    ,fold: ({ Y,N }) => o => ({ Y,N })[o.case](o.value)\n    ,map: f => o => ({\n        Y: x => Valid.Y(f(x))\n        ,N: () => o\n    })[o.case](o.value)\n}\n\nconst PatternToken = {\n    name: 'PatternToken'\n    ,Path: value =>\n        ({ case: 'Path', value, type: 'PatternToken' })\n    ,Part: value =>\n        ({ case: 'Part', value, type: 'PatternToken' })\n    ,Variadic: value =>\n        ({ case: 'Variadic', value, type: 'PatternToken' })\n\n    ,specificity: token => PatternToken.fold({\n        Path: () => 0b10\n        ,Part: () => 0b01\n        ,Variadic: () => 0b00\n    }) (token)\n\n    ,groupSpecificity: tokens => \n        tokens.map(PatternToken.specificity)\n            .reduce( (p,n) => p+n, 0)\n\n    ,fold: ({\n        Path,\n        Part,\n        Variadic\n    }) => o => ({\n        Path\n        ,Part\n        ,Variadic\n    })[o.case](o.value)\n\n    ,infer: segment =>\n        segment.startsWith(':')\n            ? PatternToken.Part(segment.slice(1))\n        : segment.startsWith('...')\n            ? PatternToken.Variadic(segment.split('...')[1])\n        : PatternToken.Path(segment)\n\n    ,groupValidations: {\n        duplicateDef: allTokensPairs => {\n\n            // Pair (CaseName, PatternStr)\n            const patterns = \n                allTokensPairs.map(\n                    ([k,v]) => [k, PatternToken.toPattern(v)]\n                )\n            \n            // StrMap (PatternStr, CaseName[])\n            const patternStrDupeSearch =\n                patterns.reduce(\n                    (p,[caseName,pattern]) => {\n                        p[pattern] = p[pattern] || []\n                        p[pattern].push(caseName)\n    \n                        return p\n                    }\n                    , {}\n                )\n    \n            // StrMap (CaseName, DupeMetaData)\n            // where \n            // DupeMetaData = \n            //  { caseNames::CaseName[], patternStr::PatternStr }\n            const caseDupes = \n                Object.entries(patternStrDupeSearch)\n                    .reduce(\n                        (p, [patternStr, caseNames]) => {\n\n                            if( caseNames.length > 1 ){\n                                caseNames.forEach(\n                                    (caseName) => {\n                                        p[caseName] = {\n                                            caseNames, patternStr\n                                        }\n                                    }\n                                )\n                            }\n                            return p\n                        }\n                        ,{}\n                    )\n\n            if ( Object.keys(caseDupes).length ){\n                return Valid.N(\n                    // StrMap (CaseName, PatternToken.Error )\n                    Object.entries(caseDupes)\n                        .map(\n                            ([caseName, { caseNames, patternStr }]) => \n                                [ caseName\n                                , PatternToken.Error.DuplicateDef({\n                                    caseNames, patternStr\n                                })\n                                ]\n                        )\n                )\n            } else {\n                return Valid.Y(\n                    allTokensPairs\n                )\n            }\n        }\n    }\n\n    ,singleValidations: {\n        variadicPosition: tokens => {\n            const index =\n                tokens.findIndex(PatternToken.isVariadic)\n\n            if (index > -1 && index != tokens.length - 1) {\n                return Valid.N(\n                    PatternToken.Error.VariadicPosition({ \n                        tokens, index \n                    })\n                )\n            } else {\n                return Valid.Y(tokens)\n            }\n        }\n\n        ,variadicCount: tokens => {\n            const variadics =\n                tokens.filter(PatternToken.isVariadic)\n\n            if (variadics.length > 1) {\n                return Valid.N(\n                    PatternToken.Error.VariadicCount({\n                        variadics, tokens\n                    })\n                )\n            } else {\n                return Valid.Y(tokens)\n            }\n        }\n\n        ,duplicatePart: tokens => {\n            \n            const dupeParts =\n                [\n                    tokens.flatMap(\n                        PatternToken.fold({\n                            Path: () => []\n                            ,Part: x => [x] \n                            ,Variadic: x => [x]\n                        })\n                    )\n                    .reduce(\n                        (p,n) => {\n                            p[n] = p[n] || 0\n                            p[n] = p[n] + 1\n                            return p\n                        }\n                        ,{}\n                    )\n                ]\n                .flatMap( \n                    o => Object.entries(o)\n                        .flatMap( ([k,v]) => v > 1 ? [k] : [])\n                )\n\n            if (dupeParts.length) {\n                return Valid.N(\n                    PatternToken.Error.DuplicatePart({\n                        dupeParts\n                    })\n                )\n            } else {\n                return Valid.Y(tokens)\n            }\n        }\n    }\n\n    ,Error: {\n        name: 'PatternToken.Error'\n        ,VariadicPosition({ tokens, index }){\n            return {\n                type: 'PatternToken.Error'\n                ,case: 'VariadicPosition'\n                ,value: new TypeError(\n                    'Variadic ' + JSON.stringify(\n                        PatternToken.toString(tokens[index])\n                    )\n                    + ' found at position ' + index + ' of ' + tokens.length \n                    + ' of pattern ' + JSON.stringify(\n                        PatternToken.toPattern(tokens)\n                    ) + '.  ' \n                    + 'Variadics can only be in the final position.'\n                )\n            }\n        }\n\n        ,VariadicCount({ variadics, tokens }){\n            return {\n                type: 'PatternToken.Error'\n                ,case: 'VariadicCount'\n                ,value: new TypeError(\n                    'Found ' + variadics.length + ' variadics in pattern '\n                    + PatternToken.toPattern(tokens) + '.  '\n                    + 'A maxiumum of 1 variadic is allowed.'\n                )\n            }\n        }\n\n        ,DuplicateDef({ caseNames, patternStr }){\n            return {\n                type: 'PatternToken.Error'\n                ,case: 'DuplicateDef'\n                ,value: new TypeError(\n                    'Found duplicate pattern definitions for '\n                    + 'routes: '+caseNames.join(', ')+'.  '\n                    + 'They all have equivalent pattern strings: '\n                    + patternStr + '.  '\n                    + 'Duplicated patterns lead to ambiguous matches.'\n                )\n            }\n        }\n\n        ,DuplicatePart({ dupeParts }){\n            return {\n                type: 'PatternToken.Error'\n                ,case: 'DuplicatePart'\n                ,value: new TypeError(\n                    'Found duplicate variable bindings: '\n                    + dupeParts.join(', ')\n                    + '.  Duplicated names lead to ambiguous bindings.'\n                )\n            }\n        }\n        \n    }\n\n    ,isVariadic: o => o.case === 'Variadic'\n\n    ,validate(tokens){\n        const out =\n            Object.values(PatternToken.singleValidations).map(\n                f => f(tokens)\n            )\n\n        const invalids = out.filter( x => x.case === 'N')\n            .map( x => x.value )\n\n        return invalids.length > 0\n            ? Valid.N(invalids)\n            : Valid.Y(tokens)\n    }\n\n    ,validateGroup(allTokensGroup){\n\n        const validTokensGroup = \n            allTokensGroup.filter( ([,v]) => v.case === 'Y' )\n            \n        const out =\n            Object.values(PatternToken.groupValidations)\n            .map(\n                f => f( validTokensGroup.map( ([k,v]) => [k, v.value] ) )\n            )\n\n        const invalids = out.filter( x => x.case === 'N')\n            .map( x => x.value )\n\n        return invalids.length > 0\n            ? Valid.N(invalids)\n            : Valid.Y(allTokensGroup)\n    }\n\n\n    ,toString: x => ({\n        Path: x => x\n        ,Part: x => ':'+x\n        ,Variadic: x => '...'+x\n    })[x.case](x.value)\n\n    ,toPattern: xs => xs.map( PatternToken.toString ).join('/')\n}\n\nconst URLToken = {\n    Path: value =>\n        ({ case: 'Path', value, type: 'URLToken' })\n    ,Part: ({ key, value }) =>\n        ({ case: 'Part', value: { key, value }, type: 'URLToken' })\n    ,Variadic: ({ key, value }) =>\n        ({ case: 'Variadic', value: { key, value }, type: 'URLToken' })\n    ,Unmatched: ({expected, actual}) =>\n        ({ case: 'Unmatched', value: { expected, actual }, type: 'URLToken' })\n    ,ExcessSegment: segment =>\n        ({ case: 'ExcessSegment', value: segment, type: 'URLToken' })\n\n    ,fold: ({\n        Path,Part,Variadic,Unmatched,ExcessSegment \n    }) => x => ({\n        Path,Part,Variadic,Unmatched,ExcessSegment\n    })[x.case](x.value)\n\n    ,toString: x => URLToken.fold({\n        Path: x => x\n        ,Part: ({ value: x }) => x\n        ,Variadic: ({ value: x }) => x\n        ,Unmatched: ({ actual: x }) => x\n        ,ExcessSegment: x => x\n    }) (x)\n\n    ,toURL: xs => xs.map( URLToken.toString ).join('/')\n\n    ,toArgs: xs => xs.reduce(\n        (p,n) => URLToken.fold({\n            ExcessSegment: () => p\n            ,Part: ({ key, value }) => \n                Object.assign(p, { [key]: value })\n            ,Path: () => p\n            ,Unmatched: () => p\n            ,Variadic: ({ key, value }) => \n                Object.assign(p, { [key]: value })\n        }) (n),\n        {}\n    )\n\n    ,fromPattern: o => segment => PatternToken.fold({\n        Path: expected =>\n            segment === expected \n                ? URLToken.Path(segment)\n                : URLToken.Unmatched({ expected, actual: segment })\n        ,Part: key =>\n            URLToken.Part({ key, value: segment })\n        ,Variadic: key =>\n            URLToken.Variadic({ key, value: segment })\n    }) (o)\n\n    ,isVariadic: o => o.case === 'Variadic'\n\n    ,validations: {\n        \n        excessPatterns: patternTokens => urlTokens => {\n\n            const numSegments = \n                urlTokens.length\n\n            const numPatterns =\n                patternTokens.length\n                \n            const excessPatterns = \n                numPatterns > numSegments\n                ? patternTokens.slice(numSegments)\n                : []\n\n            if( excessPatterns.length ){\n                return Valid.N(\n                    URLToken.Error.ExcessPattern({\n                        urlTokens, patternTokens\n                        ,excessPatterns\n                    })\n                )\n            } else {\n                return Valid.Y(urlTokens)\n            }\n        }\n\n        ,excessSegments: patternTokens => urlTokens => {\n            const extraSegments = \n                urlTokens.filter( x => x.case === 'ExcessSegment' )\n                \n            if ( extraSegments.length \n                && patternTokens.slice(-1)[0].case !== 'Variadic' \n            ){\n                return Valid.N(\n                    URLToken.Error.ExcessSegment({\n                        patternTokens, extraSegments\n                    })\n                )\n            } else {\n                return Valid.Y(urlTokens)\n            }\n        }\n\n        ,unmatchedPaths: patternTokens => urlTokens => {\n            const unmatched =\n                urlTokens.filter( x => x.case === 'Unmatched' )\n\n            if( unmatched.length ){\n                return Valid.N(\n                    URLToken.Error.UnmatchedPaths({ patternTokens, urlTokens })\n                )\n            } else {\n                return Valid.Y(urlTokens)\n            }\n        }\n        \n    }\n\n    ,Error: {\n        UnmatchedPaths({ patternTokens, urlTokens }){\n            return {\n                type: 'URLToken.Error'\n                ,case: 'UnmatchedPaths'\n                ,value:\n                    new TypeError(\n                        'Pattern '+PatternToken.toPattern(patternTokens)\n                            + ' could not match URL '\n                            + URLToken.toURL(urlTokens)\n                            + ' due to unmatched path segments: '\n                            + urlTokens.map(\n                \n                                x => x.case === 'Unmatched'\n                                    ? URLToken.toString(x)\n                                    : '...'\n                            )\n                            .join('/')\n                    )\n            }\n        }\n\n        ,ExcessSegment({ patternTokens, extraSegments }){\n            return {\n                type: 'URLToken.Error'\n                ,case: 'ExcessSegment'\n                ,value: new TypeError(\n                    'Excess tokens ('\n                        + JSON.stringify(\n                            '/'+extraSegments.map( x => x.value).join('/')\n                        )\n                        + ')'\n                    + ' were found and the URLPattern:'\n                        + JSON.stringify(\n                            PatternToken.toPattern(patternTokens)\n                        )\n                          \n                    + ' did not contain a variadic for the additional'\n                    + ' values.'\n                )\n            }\n        }\n\n        ,ExcessPattern({ urlTokens, excessPatterns, patternTokens }){\n            return {\n                type: 'URLToken.Error'\n                ,case: 'ExcessPattern'\n                ,value: new TypeError(\n                    'The URL '+ URLToken.toURL(urlTokens) \n                    +' had excess patterns ('\n                        + PatternToken.toPattern(excessPatterns)\n                    + ')'\n                    + ' when parsed as part of pattern:'\n                        + ' ' +PatternToken.toPattern(patternTokens)\n                )\n            }\n        }\n    }\n\n    ,transforms: {\n        collectVariadics: url => patternTokens => urlTokens => {\n\n            const extraSegments = \n                urlTokens.length > patternTokens.length \n                    ? urlTokens.slice( patternTokens.length )\n                    : []\n\n            if ( extraSegments.length ){\n                \n                const index =\n                    urlTokens.findIndex(URLToken.isVariadic)\n\n                // Technically not possible because excess segments\n                // without variadics isn't valid and would be caught\n                // earlier.  But typesafety 😐\n                /* istanbul ignore next */\n                if (index == -1) {\n                    return urlTokens\n                } else {\n                    const { key, value } = urlTokens[index].value\n                    \n                    return urlTokens.slice(0, patternTokens.length-1).concat(\n                        URLToken.Variadic(\n                            {\n                                key\n                                , value: value\n                                    + '/'\n                                    + url.split('/')\n                                        .slice(patternTokens.length)\n                                        .join('/')\n                            }\n                        )\n                    )\n                }\n            } else {\n                return urlTokens\n            }\n        }\n    }\n\n    ,transform: (url, urlTokens, patternTokens) => {\n        return Object.values(URLToken.transforms).reduce(\n            (p, f) => f (url) (patternTokens) (p),\n            urlTokens\n        )\n    }\n\n    ,validate(patternTokens, urlTokens){\n        const out =\n            Object.values(URLToken.validations).map(\n                f => f(patternTokens) (urlTokens)\n            )\n\n        const invalids = out.filter( x => x.case === 'N')\n            .map( x => x.value )\n\n        return invalids.length > 0\n            ? Valid.N(invalids)\n            : Valid.Y(urlTokens)\n    }\n}\n\nfunction tokenizePattern(pattern) {\n\n    const patternTokens =\n        pattern.split('/').map(PatternToken.infer)\n\n    return [patternTokens]\n            .map(PatternToken.validate)\n            .shift()\n}\n\n// always include a trailing slash internally\n// so final ...rest matches optionally\n// see: https://gitlab.com/harth/superouter/issues/4\nconst trailingIfFinalIsVariadic = (patternTokens, url) => {\n    const lastTokenIsRest = \n        patternTokens.slice(-1)\n        .map(\n            PatternToken.isVariadic\n        )\n        .shift()\n    \n    const isTrailing = \n        url[url.length -1] == '/'\n\n    return lastTokenIsRest && !isTrailing\n            ? url + '/'\n            : url\n}\n\n\nfunction tokenizeURL(patternTokens, theirURL){\n    const url = trailingIfFinalIsVariadic(patternTokens, theirURL)\n        \n    const urlTokens =\n        url.split('/').slice(0, patternTokens.length).map(\n            (segment, i) => \n                URLToken.fromPattern (patternTokens[i]) (segment)\n        )\n\n    const segments =\n        url.split('/')\n    \n    const numSegments = \n        segments.length\n\n    const numPatterns =\n        patternTokens.length\n        \n    const excessSegments = \n        numSegments > numPatterns\n        ? segments.slice(numPatterns).map(\n            URLToken.ExcessSegment\n        )\n        : []\n     \n    const completeTokens =\n        urlTokens\n        .concat(excessSegments)\n\n    \n    return [URLToken.validate(patternTokens, completeTokens)]\n        .map(\n            Valid.map(\n                () => URLToken.transform(url, completeTokens, patternTokens)\n            )\n        )\n        .shift()\n}\n\nfunction routeValidator({ tokenized }){\n    \n    const groupInvalids = \n        [\n            PatternToken.validateGroup(\n                Object.entries(tokenized)\n            )\n        ]\n        .flatMap(\n            Valid.bifold(\n                x => x, () => []\n            )\n        )\n\n    // Pair (CaseName, PatternToken.Error[])\n    const invalids =\n        Object.entries(tokenized).filter(\n            ([, tokens]) => tokens.case === 'N'\n        )\n        .map( ([key, x]) => [key, x.value] )\n        .concat(groupInvalids.reduce( (p,n) => p.concat(n), []))\n\n    if( invalids.length ){\n        return Valid.N(\n            Object.entries(tokenized)\n            .map(([k]) => [k, []])\n            .concat( invalids )\n            .reduce( (p,[k,v]) => {\n                p[k] = p[k] || []\n                p[k] = p[k].concat(v) \n                return p\n            }, {})\n                \n        )\n    } else {\n        return Valid.Y(tokenized)\n    }\n}\n\nfunction SafeRouteType({ typeName, tokenized }){\n    \n    return Object.entries(tokenized).map(\n        ([caseName, tokens]) => {\n            const keys = \n                tokens.value.reduce(\n                    (p, n) => \n                        PatternToken.fold({\n                            Path: () => p\n                            ,Part: key => p.concat(key)\n                            ,Variadic: key => p.concat(key)\n                        }) (n),\n                    []\n                )\n                .sort()\n\n            function of(o) {\n\n                const foundKeys = Object.keys(o || {}).sort()\n                \n                if( foundKeys.join('|') !== keys.join('|') ){\n                    return Valid.N( \n                        new TypeError(\n                            'Property mismatch for '\n                                +typeName+'.'+caseName\n                                + '.  Expected: {'+keys.join(',')+'}'\n                                + ' but found: {'+foundKeys.join()+'}'\n                        )\n                    )\n                } else {\n                    return Valid.Y(\n                        {\n                            type: typeName\n                            ,case: caseName\n                            ,value: o\n                        }\n                    )\n                }\n            }\n\n            return { [caseName]: of }\n        }\n    )\n    .reduce( (p,n) => Object.assign(p,n))\n}\n\nfunction RouteType({ typeName, safeRouteType }){\n\n    const Route =\n        Object.entries(safeRouteType).map(\n            ([key, of]) => ({ \n                [key]: o => Valid.fold({\n                    Y: x => x\n                    ,N(err){\n                        throw err\n                    }\n                }) ( of(o) )\n                \n            })\n        )\n        .reduce( (p,n) => Object.assign(p,n), { name: typeName })\n\n    return Route\n}\n\nconst PatternMatches = \n    ({ tokenized, url }) => {\n\n        const pairs = \n            Object.entries(tokenized).map(\n                ([key, patternTokens]) => \n                    [key, tokenizeURL(patternTokens.value, url)]\n            )\n\n        const invalid = \n            pairs\n            .filter( ([,valid]) => valid.case === 'N' )\n            .map(\n                ([key, { value }]) => ({ [key]: value})\n            )\n            .reduce( (p,n) => Object.assign(p,n), {})\n\n        const valid = \n            pairs\n            .filter( ([,valid]) => valid.case === 'Y' )\n            .sort(\n                ([,{ value: a}], [,{ value: b}]) => \n                    PatternToken.groupSpecificity(b) \n                    - PatternToken.groupSpecificity(a)\n            )\n            \n        if( valid.length ) {\n            return Valid.Y(valid)\n        } else {\n            return Valid.N(invalid)\n        }\n    }\n\nconst Matches = \n    ({ routeType }) => patternMatches => {\n\n        return Valid.bifold(\n            Valid.N,\n            xs => \n                // xs being non empty is technically a precondition\n                // to being marked as valid\n                // but we check it in any case as the types make it possible\n                xs.length == 0\n                /* istanbul ignore next */\n                ? Valid.N({})\n                : Valid.Y(\n                    xs.map(\n                        ([caseName, { value }]) => \n                            routeType[caseName](\n                                URLToken.toArgs(value)\n                            )\n                    )\n                )\n        ) (patternMatches)\n    }\n\nfunction type$safe(typeName, cases){\n    // StrMap (CaseName, Valid( N::PatternToken.Error[] | Y::PatternToken[] ) )\n    const tokenized = \n        Object.entries(cases).map(\n            ([caseName, pattern]) => {\n                return { [caseName]: tokenizePattern(pattern) }\n            }\n        )\n        .reduce( (p,n) => Object.assign(p, n), {} )\n\n    const validated = routeValidator({ tokenized })\n\n    if( validated.case === 'N' ){\n        return validated\n    } else {\n\n        const safeRouteType =\n            SafeRouteType({ typeName, tokenized })\n        \n        const routeType = \n            RouteType({ typeName, safeRouteType })\n\n        const fold = cases => o => cases[o.case](o.value)\n\n        const matches = url => {\n            const patternMatches = PatternMatches({tokenized, url})    \n            return Matches({ routeType }) (patternMatches)\n        }\n\n        const matchOr = (otherwise, url) => \n            [url]\n            .map(matches)\n            .flatMap(\n                Valid.bifold(\n                    otherwise,\n                    x => x\n                )\n            )\n            .slice(0,1)\n            .concat( otherwise({}) )\n            .shift()\n\n        const toURL = routeCase => {\n            return tokenized[routeCase.case].value.map(\n                PatternToken.fold({\n                    Part: key => routeCase.value[key]\n                    ,Path: key => key\n                    ,Variadic: key => routeCase.value[key]\n                })\n            )\n            .join('/')\n        }\n\n        return Valid.Y(\n            { safe: safeRouteType\n            , of: routeType\n            , fold\n            , matches\n            , matchOr\n            , toURL\n            }\n        )\n    }\n}\n\nconst type = \n    (typename, cases) => \n        Valid.bifold(\n            (errs) => {\n                throw Object.values(errs)\n                    .flatMap( xs =>  xs )\n                    .map( x => x.value)\n                    .shift()\n            },\n            x => x\n        ) (type$safe(typename, cases))\n\n\nexport { \n    tokenizePattern\n    , tokenizeURL\n    , PatternToken\n    , URLToken\n    , Valid\n    , type$safe\n    , type\n}"],"names":["Valid","name","Y","value","type","N","bifold","o","fold","map","f","x","PatternToken","Path","Part","Variadic","specificity","token","groupSpecificity","tokens","reduce","p","n","infer","segment","startsWith","slice","split","groupValidations","duplicateDef","allTokensPairs","patternStrDupeSearch","k","v","toPattern","caseName","pattern","push","caseDupes","Object","entries","patternStr","caseNames","length","forEach","keys","Error","DuplicateDef","singleValidations","variadicPosition","index","findIndex","isVariadic","VariadicPosition","variadicCount","variadics","filter","VariadicCount","duplicatePart","dupeParts","flatMap","DuplicatePart","TypeError","JSON","stringify","toString","join","validate","invalids","values","validateGroup","allTokensGroup","validTokensGroup","xs","URLToken","key","Unmatched","expected","actual","ExcessSegment","toURL","toArgs","assign","fromPattern","validations","excessPatterns","patternTokens","urlTokens","numSegments","ExcessPattern","excessSegments","extraSegments","unmatchedPaths","UnmatchedPaths","transforms","collectVariadics","url","concat","transform","tokenizePattern","shift","trailingIfFinalIsVariadic","lastTokenIsRest","isTrailing","tokenizeURL","theirURL","i","segments","numPatterns","completeTokens","PatternMatches","tokenized","pairs","invalid","valid","sort","a","b","Matches","routeType","patternMatches","type$safe","typeName","cases","validated","groupInvalids","routeValidator","safeRouteType","foundKeys","SafeRouteType","of","err","RouteType","matches","safe","matchOr","otherwise","routeCase","typename","errs"],"mappings":"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"}